{"version":3,"file":"getRandomValues.js","sourceRoot":"","sources":["../src/getRandomValues.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,IAAI,yBAAyB,EAAE,MAAM,aAAa,CAAC;AAE3E,MAAM,gBAAgB,GAAG,KAAK,CAAC;AAW/B;;;;;;GAMG;AACH,MAAM,CAAC,OAAO,UAAU,eAAe,CACrC,MAAc;IAEd,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;QACxB,MAAM,IAAI,SAAS,CACjB,gFAAgF,CACjF,CAAC;KACH;IAED,IACE,CAAC,CAAC,MAAM,YAAY,SAAS,CAAC;QAC9B,CAAC,CAAC,MAAM,YAAY,UAAU,CAAC;QAC/B,CAAC,CAAC,MAAM,YAAY,UAAU,CAAC;QAC/B,CAAC,CAAC,MAAM,YAAY,WAAW,CAAC;QAChC,CAAC,CAAC,MAAM,YAAY,UAAU,CAAC;QAC/B,CAAC,CAAC,MAAM,YAAY,WAAW,CAAC;QAChC,CAAC,CAAC,MAAM,YAAY,iBAAiB,CAAC,EACtC;QACA,MAAM,IAAI,SAAS,CACjB,6DAA6D,CAC9D,CAAC;KACH;IAED,IAAI,MAAM,CAAC,UAAU,GAAG,gBAAgB,EAAE;QACxC,MAAM,IAAI,kBAAkB,CAC1B,uCAAuC,MAAM,CAAC,UAAU,oEAAoE,gBAAgB,GAAG,CAChJ,CAAC;KACH;IAED,kGAAkG;IAClG,yBAAyB,CAAC,MAAM,CAAC,CAAC;IAElC,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,UAAU,uBAAuB,CACrC,MAAc;IAEd,sEAAsE;IACtE,MAAM,QAAQ,GAAG,IAAI,UAAU,CAC7B,MAAM,CAAC,MAAM,EACb,MAAM,CAAC,UAAU,EACjB,MAAM,CAAC,UAAU,CAClB,CAAC;IACF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACxC,sFAAsF;QACtF,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC;KACnC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,kBAAmB,SAAQ,KAAK;IACpC,IAAI,GAAG,oBAAoB,CAAC;IAC5B,IAAI,GAAG,EAAE,CAAC,CAAC,qBAAqB;CACjC","sourcesContent":["import { getRandomValues as expoCryptoGetRandomValues } from \"expo-crypto\";\n\nconst MAX_RANDOM_BYTES = 65536;\n\ntype IntegerArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\n/**\n * An implementation of Crypto.getRandomValues that uses expo-random's secure random generator if\n * available and falls back to Math.random (cryptographically insecure) when synchronous bridged\n * methods are unavailable.\n *\n * See https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues\n */\nexport default function getRandomValues<TArray extends ArrayBufferView>(\n  values: TArray\n): TArray {\n  if (arguments.length < 1) {\n    throw new TypeError(\n      `An ArrayBuffer view must be specified as the destination for the random values`\n    );\n  }\n\n  if (\n    !(values instanceof Int8Array) &&\n    !(values instanceof Uint8Array) &&\n    !(values instanceof Int16Array) &&\n    !(values instanceof Uint16Array) &&\n    !(values instanceof Int32Array) &&\n    !(values instanceof Uint32Array) &&\n    !(values instanceof Uint8ClampedArray)\n  ) {\n    throw new TypeError(\n      `The provided ArrayBuffer view is not an integer-typed array`\n    );\n  }\n\n  if (values.byteLength > MAX_RANDOM_BYTES) {\n    throw new QuotaExceededError(\n      `The ArrayBuffer view's byte length (${values.byteLength}) exceeds the number of bytes of entropy available via this API (${MAX_RANDOM_BYTES})`\n    );\n  }\n\n  // Removed try/catch. If it throws an exception, pass it, never generate an insecure random number\n  expoCryptoGetRandomValues(values);\n\n  return values;\n}\n\nexport function getRandomValuesInsecure<TArray extends IntegerArray>(\n  values: TArray\n): TArray {\n  // Write random bytes to the given TypedArray's underlying ArrayBuffer\n  const byteView = new Uint8Array(\n    values.buffer,\n    values.byteOffset,\n    values.byteLength\n  );\n  for (let i = 0; i < byteView.length; i++) {\n    // The range of Math.random() is [0, 1) and the ToUint8 abstract operation rounds down\n    byteView[i] = Math.random() * 256;\n  }\n  return values;\n}\n\nclass QuotaExceededError extends Error {\n  name = \"QuotaExceededError\";\n  code = 22; // QUOTA_EXCEEDED_ERR\n}\n"]}